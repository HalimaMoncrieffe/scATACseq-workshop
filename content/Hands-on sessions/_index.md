---
title: "1. Hands-on sessions"
---

## Day 1 

### Hands-on session 1: Processing bulk ATAC-seq

> Download fastq

Here we will process one of the first samples generated by ATAC-seq, from (doi: 10.1038/nmeth.2688)[https://doi.org/10.1038/nmeth.2688].
This is an ATAC-seq sample from GM12878 cells. Let's first download the raw fastqs. 

```shell
mkdir -p data/GM12878/fastq
wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR891/SRR891269/SRR891269_1.fastq.gz -O data/GM12878/fastq/GM12878_R1.fq.gz
wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR891/SRR891269/SRR891269_2.fastq.gz -O data/GM12878/fastq/GM12878_R2.fq.gz
```

> Process GM12878 data

The processing steps for ATAC-seq are: 

1. Adapter trimming
2. Read pairs mapping
3. Read pairs filtering
4. Track generation
5. Peak calling

```shell
cd data/GM12878
SAMPLE=GM12878
R1=fastq/GM12878_R1.fq.gz
R2=fastq/GM12878_R2.fq.gz
GENOME=~/genomes/hg38/hg38.fa
SAMFILE=GM12878.sam
FILTEREDBAM=GM12878_filtered.bam
TRACK=GM12878.bw
PEAKFOLDER=peaks/GM12878
GENOMESIZE=2600000000
CPU=2

## -- Trim reads and run QC
trim_galore \
    --paired \
    --fastqc \
    --cores 1 \
    "${R1}" "${R2}"

## -- Map reads 
bowtie2 \
    --threads "${CPU}" \
    -x "${GENOME}" \
    --maxins 2000 \
    -1 `echo "${R1}" | sed 's,.fastq.gz,_val_1.fq.gz,'` \
    -2 `echo "${R2}" | sed 's,.fastq.gz,_val_2.fq.gz,'` > "${SAMFILE}"

## -- Filter reads 
samtools fixmate -@ "${CPU}" --output-fmt bam -m "${SAMFILE}" - | \
samtools sort -@ "${CPU}" --output-fmt bam -T "${SAMFILE}"_sorting - | \
samtools markdup -@ "${CPU}" --output-fmt bam -r -T "${SAMFILE}"_markdup - - | \
samtools view -@ "${CPU}" --output-fmt bam -f 2 -q 10 -1 -b - | \
samtools sort -@ "${CPU}" --output-fmt bam -l 9 -T "${SAMFILE}"_sorting2 -o "${FILTEREDBAM}"
samtools index -@ "${CPU}" "${FILTEREDBAM}"

## -- Generate track
bamCoverage \
    --bam "${FILTEREDBAM}" \
    --outFileName "${TRACK}" \
    --binSize 1 \
    --numberOfProcessors "${CPU}" \
    --normalizeUsing CPM \
    --skipNonCoveredRegions \
    --extendReads \
    --ignoreDuplicates

## -- Call peaks
macs2 callpeak \
    -t "${FILTEREDBAM}" \
    --format BAMPE \
    --gsize "${GENOMESIZE}" \
    --outdir "${PEAKFOLDER}" \
    --name "${SAMPLE}"
```

> QC of GM12878 data

To check the quality of an ATAC-seq sample, one can check the following metrics: 

1. Fragment size distribution
2. Distance from fragment to TSS
3. 1+2 combined: Vplots 
4. TSS enrichment score (coverage enrichment at TSSs)
5. Location of peaks vs. genomic features
6. Fraction of fragments within peaks

```r
library(AnnotationDbi)
library(tidyverse)
library(plyranges)
library(annotatr)
library(VplotR)

## -- Import genomic features
hg_genes <- AnnotationHub::AnnotationHub()[['AH92109']] %>% 
    filter(type == 'gene', gene_biotype == 'protein_coding') %>% 
    filter(!(grepl('GL|KI', seqnames)))
seqlevelsStyle(hg_genes) <- 'UCSC'
hg_TSSs <- hg_genes %>% 
    anchor_start() %>% 
    resize(width = 1) %>% 
    unanchor()
hg_promoters <- hg_TSSs %>%
    flank_upstream(4000) %>% 
    shift_downstream(2000) %>% 
    mutate(ID = paste0('prom_', 1:n()))
hg_features <- build_annotations(
    genome = 'hg38',
    annotations = 'hg38_basicgenes'
)

## -- Import fragments and peaks as GRanges
fragments <- importPEBamFiles(
    'GM12878_filtered.bam', 
    shift_ATAC_fragments = TRUE
)
peaks <- import('peaks/GM12878/GM12878_peaks.narrowPeak')
peak_summits <- import('peaks/GM12878/GM12878_summits.bed')

## -- Check fragment size distribution
df<-as_tibble(fragments) %>% 
    group_by(width) %>% 
    count() %>% 
    ungroup() 
p1<-ggplot(df, aes(x = width, y = n)) + 
    geom_line() + 
    theme_minimal() + 
    theme(legend.position = 'none') + 
    labs(title = 'Distribution of ATAC-seq fragment size', x = 'Fragment size', y = '# of fragments')

## -- Check distance to TSS
df<-add_nearest_distance(fragments, hg_TSSs) %>%
    as_tibble() %>% 
    mutate(distance = cut(distance, breaks = seq(0, 5e5, by = 10), include.lowest = TRUE) %>% as.numeric() %>% `*`(10)) %>%
    group_by(distance) %>% 
    count() %>% 
    ungroup() %>% 
    mutate(cumsum = cumsum(n), pct = cumsum/max(cumsum))
p2<-ggplot(df, aes(x = distance, y = pct)) + 
    geom_line() + 
    theme_minimal() + 
    scale_x_log10() +
    theme(legend.position = 'none') + 
    labs(title = 'Cumulative distribution of ATAC-seq fragments', x = 'Distance from TSS', y = 'Cum. %')

## -- Check Vplot
p3<-plotVmat(
    fragments, 
    hg_TSSs, 
    normFun = 'zscore', 
    ylim = c(20, 800), 
    xlim = c(-500, 500)
)

## -- Compute promoter (TSS) Enrichment Score
df<-resize(fragments, width = 1, fix = 'center') %>% 
    join_overlap_left(hg_promoters) %>% 
    plyranges::select(ID) %>%
    as_tibble() %>% 
    filter(!is.na(ID)) %>%
    left_join(as_tibble(hg_promoters) %>% dplyr::select(start, end, ID), by = 'ID') %>% 
    mutate(
        prom_mid = start.y + (end.y - start.y) / 2, 
        distance = start.x - prom_mid, 
        binned_distance = round(distance/100, 0)*100
    ) %>%
    count(binned_distance) %>%
    mutate(
        bg = mean(.data$n[abs(.data$binned_distance) == 2000]), 
        enrich_score = n/bg
    )
TSSES <- round(df[df$binned_distance == 0, 'enrich_score'], 2)
p4<-ggplot(df, aes(x = binned_distance, y = enrich_score)) + 
    geom_line() + 
    theme_minimal() + 
    theme(legend.position = 'none') + 
    labs(title = glue::glue('TSS enrichment score (Signal-to-noise ratio): {TSSES}'), x = 'Distance from TSS', y = 'Enrich. score')

## -- Check location of peaks vs genomic features
peaks_annotated <- annotate_regions(
    peak_summits, 
    annotations = hg_features,
    ignore.strand = TRUE
)
p5<-plot_annotation(
    annotated_regions = peaks_annotated,
    annotation_order = paste0('hg38_genes_', c('promoters', '1to5kb', '5UTRs', 'exons', 'introns', '3UTRs')),
    plot_title = 'ATAC peaks',
    x_label = 'Genomic features',
    y_label = 'Count'
) + theme_minimal()

## -- Compute FRiP 
df<-add_nearest_distance(fragments, peaks) %>%
    as_tibble() %>% 
    mutate(isInPeak = distance == 0)
pct <- round(sum(df$isInPeak == 1) / nrow(df) * 100, 2)
p6<-ggplot(df, aes(y = isInPeak)) + 
    geom_bar() + 
    theme_minimal() + 
    theme(legend.position = 'none') + 
    labs(title = glue::glue('Fraction of reads in peaks (FRiP): {pct}'), x = '# of fragments', y = 'Fragment within peak')

## -- All plots together
p <- cowplot::plot_grid(
    p1, p2, p3, p4, p5, p6, 
    nrow = 2
)
ggsave('ATACseq_QC.pdf', w = 15, h = 10)
```

### Hands-on session 2: Processing single-cell ATAC-seq

Single-cell ATAC-seq data processing can be performed just like bulk ATAC-seq, as long as the 
sequencing strategy is similar (e.g. in ATAC-seq from individually sorted cells). 
However, 10X genomics does not follow the regular sequencing strategy used for standard 
Illumina libraries, as it needs to sequenced internal barcodes. 10X genomics has come up 
with a toolkit to process 10X scATACseq data into a single `bam` file, to identify peaks of 
chromatin accessibility in the entire set of single cells, and to count fragments overlapping 
with each peak in each cell. 

> Download fastqs

```shell
mkdir -p data/PBMCs_10X/
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_pbmc_1k_v1/atac_pbmc_1k_v1_fastqs.tar -O data/PBMCs_10X/atac_pbmc_1k_v1_fastqs.tar.gz
tar -xf data/PBMCs_10X/atac_pbmc_1k_v1_fastqs.tar.gz
mv atac_pbmc_1k_v1_fastqs data/PBMCs_10X/fastqs
```

> Perform cellranger-atac count job on a HPC (Slurm)

It is (almost) necessary to run `cellranger-atac count` workflow from an HPC node. Requirements are 
very high (see here for more details: https://support.10xgenomics.com/single-cell-atac/software/overview/system-requirements) 
and processing times can be quite long. It is a completely different workflow than the one used for 10X scRNAseq!!

```shell
CPU=48
MEM=256G
salloc \
    -J cellranger_atac_count \
    --cpus-per-task "${CPU}" \
    --mem "${MEM}" 
```

Once the allocated node is ready: 

```shell
CPU=48
MEM=256G
ID=PBMCs_10X
REF=~/genomes/refdata-cellranger-arc-hg19-2020-A-2.0.0/
FASTQS=data/PBMCs_10X/fastqs
module load cellranger-atac
cellranger-atac count \
    --id "${ID}" \
    --reference "${REF}" \
    --fastqs "${FASTQS}" \
    --localcores "${CPU}" \
    --localmem "${MEM}"
```

Or, to submit the job itself from main server: 

```shell
CPU=48
MEM=256G
ID=PBMCs_10X
REF=~/genomes/refdata-cellranger-arc-hg19-2020-A-2.0.0/
FASTQS=data/PBMCs_10X/fastqs
sbatch \
    -J cellranger_atac_count \
    -o cellranger_atac_count.pbmc.out \
    -e cellranger_atac_count.pbmc.err \
    --cpus-per-task "${CPU}" \
    --mem "${MEM}" \
    --export=ALL \
    bin/submit_cellranger-atac-count.sh 
```

Once the analysis is done, you can check the generated files and QC reports. 
See here for more details: https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/using/count/. 
Our QC file is in:

```shell
data/PBMCs_10X/atac_pbmc_1k_v1_web_summary.html
```

## Day 2 

### Hands-on session 3: analysing scATACseq with Signac

Here, we will focus on an example dataset generated by 10X Genomics: a set of ~5,000 cells from an mouse adult brain. 
Processed data (generated by `cellranger-atac count`) can be downladed from here: 

```shell
mkdir -p data/MouseBrain
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_analysis.tar.gz -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_analysis.tar.gz
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.tar.gz -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.tar.gz
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5 -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_tf_bc_matrix.tar.gz -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_filtered_tf_bc_matrix.tar.gz
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_tf_bc_matrix.h5 -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_filtered_tf_bc_matrix.h5
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_peak_annotation.tsv -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_peak_annotation.tsv
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_peaks.bed -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_peaks.bed
wget https://cg.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_possorted_bam.bam -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_possorted_bam.bam
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_possorted_bam.bam.bai -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_possorted_bam.bam.bai
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_raw_peak_bc_matrix.tar.gz -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_raw_peak_bc_matrix.tar.gz
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_raw_peak_bc_matrix.h5 -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_raw_peak_bc_matrix.h5
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_singlecell.csv -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_singlecell.csv
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_summary.csv -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_summary.csv
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_summary.json -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_summary.json
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_web_summary.html -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_web_summary.html
wget https://cf.10xgenomics.com/samples/cell-atac/1.2.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_cloupe.cloupe -O data/MouseBrain/atac_v1_adult_brain_fresh_5k_cloupe.cloupe
```

> Importing data

scATACseq raw data processing can be very different from bulk ATAC-seq, and downstream analysis is also quite specific to single-cell assays.
As of today, `Signac` is one of the few solutions developed to investigate scATACseq data in R, and is the most widely used approach. `Signac` is 
an "extension" of `Seurat`, which originally focused on single-cell RNA-seq data analysis. It uses the same type of object structure. 
A slight difference regarding the features is that they are actually chromatin accessible loci, rather than genes. Because peaks are frequently 
studied in relation to neighbouring genes, the `Seurat` object can conventiently store gene annotations (or any type of genomic annotations) 
in its `annotation` slot. 

```r
library(Signac)
library(Seurat)
library(tidyverse)
library(BiocParallel)
library(plyranges)

## -- Read brain ATAC-seq counts
brain_assay <- Signac::CreateChromatinAssay(
    counts = Seurat::Read10X_h5("data/MouseBrain/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5"),
    sep = c(":", "-"),
    genome = "mm10",
    fragments = 'data/MouseBrain/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz',
    min.cells = 1
)
class(brain_assay)

## -- Create Seurat object
metadata <- vroom::vroom(
    file = "data/MouseBrain/atac_v1_adult_brain_fresh_5k_singlecell.csv",
    col_names = TRUE
) %>% 
    filter(barcode != 'NO_BARCODE') %>% 
    mutate(cell = barcode) %>%
    column_to_rownames('barcode') %>% 
    as.data.frame()
brain <- Seurat::CreateSeuratObject(
    counts = brain_assay,
    assay = 'peaks',
    project = 'ATAC',
    meta.data = metadata
)

## -- Add genome annotations
Annotation(brain) <- AnnotationHub::AnnotationHub()[['AH49547']] %>% 
    filter(gene_type == 'protein_coding', type == 'gene') %>% 
    mutate(gene_biotype = gene_type)
```

> Accessing data 

Accessing the data stored in a `Seurat` object is (generally) relatively easy, using the `getAssayData()` function.

```r
# Data slots available in the Seurat object
Assays(brain)
slots <- slotNames(brain@assays[[brain@active.assay]])

# Find peaks 
peaks <- GetAssayData(brain, slot = 'ranges')

# Find counts 
counts <- GetAssayData(brain, slot = "counts")
data <- GetAssayData(brain, slot = "data")

# Find annotations
annots <- GetAssayData(brain, slot = "annotation")

# Find seqinfo 
seqinfo <- GetAssayData(brain, slot = "seqinfo")
```

> Annotate peaks

```r
peaks <- granges(brain)
annots <- Annotation(brain) 
annotated_peaks <- join_nearest(peaks, annots) %>% 
    add_nearest_distance(annots) %>% 
    mutate(
        peak = paste(seqnames, start, end, sep = '-'),
        inGene = distance == 0
    )
table(annotated_peaks$inGene)

# - Distance to nearest promoter 
mm_promoters <- Annotation(brain) %>% 
    resize(1, fix = 'start') %>% 
    resize(4000, fix = 'center') %>% 
    mutate(prom_id = paste0('prom_', 1:n()))
add_nearest_distance(peaks, mm_promoters) %>% 
    as_tibble() %>% 
    pull(distance) %>% 
    quantile(probs = seq(0, 1, 0.1))
```

> QCing data 

QC of scATACseq data stored in `Seurat` is simplified, using `Signac`-provided functions. On top of these utilities, 
scATACseq fragments can always be imported (remember: they are stored in the `fragments.tsv.gz` generated by 
`cellranger-atac count`, and they also contain information re: the cell-of-origin, for each fragment), 
if one wants to manually check fragment distribution, size, ...

```r
## -- Nucleosome signal 
brain <- NucleosomeSignal(object = brain)
brain$nucleosome_group <- ifelse(brain$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
range(brain$nucleosome_group)
table(brain$nucleosome_group)

## -- Frag. size distribution
frags <- vroom::vroom('/data/20210804_scATACseq-workshop/data/MouseBrain/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz', col_names = FALSE) %>% 
    setNames(c('chr', 'start', 'stop', 'cell', 'cluster'))
frags_chr12 <- filter(frags, chr == 'chr12', start < 50000000, cluster %in% c(1:10))
x <- left_join(frags_chr12, dplyr::select(brain@meta.data, cell, nucleosome_group)) %>% 
    mutate(width = stop - start) 
p <- ggplot(x, aes(x = width)) + 
    geom_bar() + 
    facet_wrap(~nucleosome_group+cluster, scales = 'free', ncol = 10) + 
    xlim(c(0, 800))

## -- TSS enrichment
brain <- TSSEnrichment(brain, fast = TRUE)
brain$high.tss <- ifelse(brain$TSS.enrichment > 2, 'High', 'Low')

df <- frags_chr12 %>% 
    left_join(dplyr::select(brain@meta.data, cell, high.tss)) %>% # For each fragment, recover cell TSS enrich. status
    dplyr::rename(c('seqnames' = 'chr', 'end' = 'stop')) %>% 
    as_granges() %>% 
    join_overlap_left(plyranges::select(mm_promoters, prom_id)) %>% # Link each fragment to overlapping promoter
    as_tibble() %>% 
    drop_na(prom_id) %>% # Remove fragments which are not overlapping any promoter
    left_join(
        as_tibble(mm_promoters), by = c('prom_id')
    ) %>% 
    mutate(
        midprom = start.y + (end.y - start.y)/2, 
        distance = midprom - start.x
    ) %>%
    filter(high.tss == 'High') %>%
    count(distance)
p<- ggplot(df, aes(x = distance, y = n)) + 
    geom_col() + 
    geom_smooth(method = 'loess', span = 0.05) + 
    theme_minimal() + 
    theme(legend.position = 'none') + 
    labs(title = 'Fragment "cut" sites', x = 'Distance from TSS', y = '# of cut sites') + 
    xlim(c(-1000, 1000))

```

> Subsetting data

Cell selection can be done based on some QC metrics (e.g. FRiP, FRiBl). 
Feature selection can be done based on a count threshold. 

```r
brain$FRiP <- brain$peak_region_fragments / brain$passed_filters * 100
brain$FRiBl <- brain$blacklist_region_fragments / brain$peak_region_fragments
brain <- subset(
  brain,
  peak_region_fragments > 3000 & # Keep cells with high number of fragments in peaks
    peak_region_fragments < 100000 & # Remove cells with number of fragments in peaks too high
    FRiP > 50 & # Keep cells with high FRiP 
    FRiBl < 0.05 & # Keep cells with low FRiBl
    nucleosome_signal < 4 & # Remove cells with high nucleosome signal
    TSS.enrichment > 2 # Keep cells with good TSSES
)
brain <- brain[
    rowSums(GetAssayData(brain, slot = "counts")) > 10 & 
    rowSums(GetAssayData(brain, slot = "counts") > 0) > 10, 
]
```

> Normalizing and reduce dimensionality data 

Data normalization and dimensionality reduction is done differently in scATACseq, compared to scRNAseq. This is
mostly due to the fact that scATACseq data is overly sparse, compared to (already quite sparse) scRNAseq data. 
For more info, read `Signac` pre-print: (Multimodal single-cell chromatin analysis with Signac)[https://www.biorxiv.org/content/10.1101/2020.11.09.373613v1.full]
To alleviate normalization problems linked to massive sparsity, an alternative normalization approach based on a "term frequency-inverse document frequency" approach. 
TF-IDF transformation yields metrics reflecting how important a "word" is to a "document" in a "collection" 
(in this case, a "word" is an accessible chromatin locus, a "document" is a cell, and the "collection" is the entire set of cells).

Dimensions of the normalized data matrix generated by this transformation are then reduced using singular value decomposition (SVD). 

```r
brain <- Signac::RunTFIDF(brain) # Normalize data
brain <- Signac::FindTopFeatures(brain, min.cutoff = 'q0') # Find variable features
brain <- Signac::RunSVD(object = brain) # Perform dimensionality reduction
```

> Clustering 

Now that cells are embedded in a lower dimensional space, they can be graph-clustered just like "regular" cells from scRNAseq. 

```r
brain <- FindNeighbors(object = brain, reduction = 'lsi', dims = 2:30)
brain <- FindClusters(object = brain, algorithm = 3, resolution = 1.2, verbose = FALSE)
saveRDS(brain, 'data/MouseBrain/brain.rds')
brain <- RunUMAP(brain, reduction = 'lsi', dims = 2:30)
```

> DA with Seurat 

Differential accessibility analysis of chromatin loci in scATACseq is a difficult exercise, which is still very experimental and rapidly-evolving. 
One "easy" way to perform DA analysis within a scATACseq workflow is to rely on the already-existing `FindMarkers()` function from `Seurat`. 
This approach has not been very thoroughly used yet, but allows quick-n-dirty exploratory analysis of the chromatin loci differently accessible 
between pairs of (goups of) clusters. 

```r
da_peaks <- Seurat::FindMarkers(
    object = brain,
    ident.1 = c(10, 16),
    ident.2 = c(4, 5),
    min.pct = 0.05,
    test.use = 'LR',
    latent.vars = 'peak_region_fragments'
)
```

### Hands-on session 4: Peaks differential accessibility analysis

> Processing raw ATAC data

In this section, we will rely on worm bulk ATACseq data obtained from isolated tissues, to study differential accessibility analysis. 

```shell
## -- Download raw data 
mkdir data/ATAC_worm/fastq/
curl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR105/079/SRR10564679/SRR10564679_1.fastq.gz -o data/ATAC_worm/fastq/SRR10564679_GSM4197239_Neurons_YA_ATAC_pe_rep1_Caenorhabditis_elegans_ATAC-seq_1.fastq.gz
curl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR105/079/SRR10564679/SRR10564679_2.fastq.gz -o data/ATAC_worm/fastq/SRR10564679_GSM4197239_Neurons_YA_ATAC_pe_rep1_Caenorhabditis_elegans_ATAC-seq_2.fastq.gz
curl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR105/086/SRR10564686/SRR10564686_1.fastq.gz -o data/ATAC_worm/fastq/SRR10564686_GSM4197244_Neurons_YA_ATAC_pe_rep2_Caenorhabditis_elegans_ATAC-seq_1.fastq.gz
curl -L ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR105/086/SRR10564686/SRR10564686_2.fastq.gz -o data/ATAC_worm/fastq/SRR10564686_GSM4197244_Neurons_YA_ATAC_pe_rep2_Caenorhabditis_elegans_ATAC-seq_2.fastq.gz

## -- Process data 
GENOME=~/genomes/ce11/ce11.fa
CPU=16 
SAMPLE=Neurons_rep1
R1=data/ATAC_worm/fastq/SRR10564679_GSM4197239_Neurons_YA_ATAC_pe_rep1_Caenorhabditis_elegans_ATAC-seq_1.fastq.gz
R2=data/ATAC_worm/fastq/SRR10564679_GSM4197239_Neurons_YA_ATAC_pe_rep1_Caenorhabditis_elegans_ATAC-seq_2.fastq.gz
bowtie2 --threads "${CPU}" -x "${GENOME}" --maxins 1000 -1 "${R1}" -2 "${R2}" | \
samtools fixmate -@ "${CPU}" --output-fmt bam -m - - | \
samtools sort -@ "${CPU}" --output-fmt bam -T data/ATAC_worm/"${SAMPLE}".sam_sorting - | \
samtools markdup -@ "${CPU}" --output-fmt bam -r -T data/ATAC_worm/"${SAMPLE}".sam_markdup - - | \
samtools view -@ "${CPU}" --output-fmt bam -f 2 -q 10 -1 -b - | \
samtools sort -@ "${CPU}" --output-fmt bam -l 9 -T data/ATAC_worm/"${SAMPLE}".sam_sorting2 -o data/ATAC_worm/"${SAMPLE}"_filtered.bam
samtools index -@ "${CPU}" data/ATAC_worm/"${SAMPLE}"_filtered.bam
SAMPLE=Neurons_rep2
R1=data/ATAC_worm/fastq/SRR10564686_GSM4197244_Neurons_YA_ATAC_pe_rep2_Caenorhabditis_elegans_ATAC-seq_1.fastq.gz
R2=data/ATAC_worm/fastq/SRR10564686_GSM4197244_Neurons_YA_ATAC_pe_rep2_Caenorhabditis_elegans_ATAC-seq_2.fastq.gz
bowtie2 --threads "${CPU}" -x "${GENOME}" --maxins 1000 -1 "${R1}" -2 "${R2}" | \
samtools fixmate -@ "${CPU}" --output-fmt bam -m - - | \
samtools sort -@ "${CPU}" --output-fmt bam -T data/ATAC_worm/"${SAMPLE}".sam_sorting - | \
samtools markdup -@ "${CPU}" --output-fmt bam -r -T data/ATAC_worm/"${SAMPLE}".sam_markdup - - | \
samtools view -@ "${CPU}" --output-fmt bam -f 2 -q 10 -1 -b - | \
samtools sort -@ "${CPU}" --output-fmt bam -l 9 -T data/ATAC_worm/"${SAMPLE}".sam_sorting2 -o data/ATAC_worm/"${SAMPLE}"_filtered.bam
samtools index -@ "${CPU}" data/ATAC_worm/"${SAMPLE}"_filtered.bam

# This was repeated for 4 other tissues
```

> Defining a unified set of peaks from a bunch of ATAC-seq experiments

When dealing with bulk ATAC-seq samples (or "pseudo-bulk" samples from scATACseq), another approach is to cluster accessible chromatin loci
based on their levels of accessibility in each sample. This can leverage a traditional `DESeq2` workflow, but first, one needs to identify a 
set of chromatin loci overlapping *all* the accessible sites of each sample. 

An approach to do this (if not using `cellranger-atac count`-identified peaks) can be to use `yapc` (yet another peak caller) command-line tool. 
`yapc` relies on the ATAC-seq coverage "shape" of duplicates to identify "concave" coverage regions (i.e. "peaks"). 
So we need bigwig tracks of each ATAC-seq experiment to map peaks with `yapc`.

```shell
## -- Downloading tracks 
mkdir data/ATAC_worm
wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE141nnn/GSE141210/suppl//GSE141210_RAW.tar?tool=geoquery -O data/ATAC_worm/ATACseq_tracks.tar.gz
tar -xvf data/ATAC_worm/ATACseq_tracks.tar.gz -C data/ATAC_worm/

## -- Find peaks with yapc
yapc data/ATAC_worm/yapc \
    Germline data/ATAC_worm/GSM4197238_Germline_YA_ATAC_pe_rep1.bw data/ATAC_worm/GSM4197243_Germline_YA_ATAC_pe_rep2.bw \
    Neurons data/ATAC_worm/GSM4197239_Neurons_YA_ATAC_pe_rep1.bw data/ATAC_worm/GSM4197244_Neurons_YA_ATAC_pe_rep2.bw \
    Muscle data/ATAC_worm/GSM4197240_Muscle_YA_ATAC_pe_rep1.bw data/ATAC_worm/GSM4197245_Muscle_YA_ATAC_pe_rep2.bw \
    Hypodermis data/ATAC_worm/GSM4197241_Hypodermis_YA_ATAC_pe_rep1.bw data/ATAC_worm/GSM4197246_Hypodermis_YA_ATAC_pe_rep2.bw \
    Intestine data/ATAC_worm/GSM4197242_Intestine_YA_ATAC_pe_rep1.bw data/ATAC_worm/GSM4197247_Intestine_YA_ATAC_pe_rep2.bw

## -- Further processing depending on what you intend to do 
# .....
# Details of how the identified peaks were further processed are available in Serizay et al., Genome Research 2020. 
# Eventually, ~15,000 tissue-specific promoters were identified in this study, and available from VplotR::ce11_proms
```

> Counting reads over peaks

From the ~ 45,000 identified peaks with `yapc`, we annotated and filtered down ~ 17,000 promoters. 
We can compute the coverage of each promoter in each of the 10 ATAC-seq samples in `R` using 
`featureCounts()`  function from `R` wrapper of `subread`.

```r
files <- c(
    'data/ATAC_worm/Germline_rep1_filtered.bam',
    'data/ATAC_worm/Germline_rep2_filtered.bam',
    'data/ATAC_worm/Neurons_rep1_filtered.bam',
    'data/ATAC_worm/Neurons_rep2_filtered.bam',
    'data/ATAC_worm/Muscle_rep1_filtered.bam',
    'data/ATAC_worm/Muscle_rep2_filtered.bam',
    'data/ATAC_worm/Hypodermis_rep1_filtered.bam',
    'data/ATAC_worm/Hypodermis_rep2_filtered.bam',
    'data/ATAC_worm/Intestine_rep1_filtered.bam',
    'data/ATAC_worm/Intestine_rep2_filtered.bam'
)
gtf <- 'data/ATAC_worm/ce11_proms.gtf'
cnts <- Rsubread::featureCounts(
    files = files, 
    annot.ext = 'data/ATAC_worm/ce11_proms.gtf', 
    isGTFAnnotationFile = TRUE, 
    GTF.featureType = 'sequence_feature', 
    GTF.attrType = 'id', 
    isPairedEnd = TRUE, 
    nthreads = 16
)
```

> Performing DA tests 

`DESeq2` time-tested workflow can be followed, starting from the counts obtained by `featureCounts`. 

```r
library(tidyverse)
library(SummarizedExperiment)
library(DESeq2)

data(ce11_proms, 'VplotR')
counts <- SummarizedExperiment(
    assays = list('counts' = cnts$counts), 
    rowRanges = ce11_proms,
    colData = S4Vectors::DataFrame(
        sample = cnts$targets, 
        tissue = factor(str_replace_all(cnts$targets, '_.*', ''), c('Germline', 'Neurons', 'Muscle', 'Hypodermis', 'Intestine')), 
        rep = str_replace_all(cnts$targets, '_filtered.bam|.*rep', '')
    )
)

dds <- DESeqDataSet(counts, design = ~ tissue)
dds <- DESeq(dds)

contrasts <- levels(counts$tissue) %>% 
    combn(2, simplify = FALSE) %>% 
    lapply(function(x) {c("tissue", x[2], x[1])})
contrasts_names <- sapply(contrasts, function(x) paste0(x[2], "_vs_", x[3]))
out.l2fc <- data.frame(matrix(nrow=length(ce11_proms), ncol=length(contrasts))) ; colnames(out.l2fc) <- paste0(contrasts_names, '.l2FC')
out.padj <- data.frame(matrix(nrow=length(ce11_proms), ncol=length(contrasts))) ; colnames(out.padj) <- paste0(contrasts_names, '.padj')
for (i in 1:length(contrasts)) {
    res <- results(dds, contrast = contrasts[[i]])
    metadata(res)$alpha <- 0.01
    out <- as.data.frame(res)
    out.l2fc[,i] <- out[,2]
    out.padj[,i] <- out[,6]
}

FPM <- fpm(dds, robust = FALSE)
colnames(FPM) <- paste0('FPM_', counts$sample) %>% str_replace_all('_filtered.bam', '')

results <- cbind(
    as.data.frame(ce11_proms),
    FPM,
    out.l2fc,
    out.padj
)
results$sign.l2FC <- apply(results[,grepl("l2FC", colnames(results))], 1, function(x) any(x < -log2(2) | x > log2(2)))
results$sign.padj <- apply(results[,grepl("padj", colnames(results))], 1, function(x) any(x < 0.01))
write.table(results, 'data/ATAC_worm/quantif.txt', quote = FALSE, col.names = TRUE, row.names = FALSE, sep = '\t')

rowData(dds) <- cbind(
    rowData(dds), 
    FPM,
    out.l2fc,
    out.padj
)
saveRDS(dds, 'data/ATAC_worm/quantif.rds')
```

> Clustering peaks 

```r
rlogs <- DESeq2::rlog(dds, blind = FALSE) %>% 
    assay() %>% 
    as_tibble() %>%
    setNames(paste0('rlog_', dds$sample) %>% str_replace_all('_filtered.bam', '')) %>% 
    mutate(id = paste0('prom_', 1:n())) %>% 
    pivot_longer(-id, names_to = 'class', values_to = 'rlog') %>% 
    separate(class, into = c(NA, 'tissue', 'rep'), sep = '_') %>% 
    group_by(id, tissue) %>% 
    summarize(rlog = mean(rlog)) %>% 
    pivot_wider(names_from = tissue, values_from = rlog) %>%
    ungroup() %>%
    filter(rowSums(select(., -id)) > 0)
clusts <- cluster::pam(select(rlogs, -id), k = 9)
p <- pheatmap::pheatmap(
    select(rlogs, -id)[order(clusts$clustering), ], 
    cluster_rows = FALSE, 
    cluster_cols = FALSE, 
    breaks = seq(0, 12, length.out = 100), 
    colorRampPalette(c("#ffffff", "#ffffff", "#dda937", "#E31A1C", "#a51618"))(100)
)
```

## Day 3 

### Hands-on session 5: Motif and TF analysis of peak clusters 

> Scan genome for JASPAR motifs

```r
motifs <- TFBSTools::getMatrixSet(
    JASPAR2020::JASPAR2020,
    list(species = 6239, all_versions = FALSE)
)
ce11_seq <- Biostrings::getSeq(BSgenome.Celegans.UCSC.ce11::BSgenome.Celegans.UCSC.ce11)
motifs_hits <- BiocParallel::bplapply(motifs, function(motif) {
    TF <- TFBSTools::name(motif)
    message(TF)
    TFBSTools::searchSeq(as(motif, 'PWMatrix'), ce11_seq, min.score = 0.95) %>% 
        lapply(as, 'GRanges') %>% 
        GenomicRanges::GRangesList() %>% 
        unlist()
}) %>% purrr::set_names(TFBSTools::name(motifs)) %>% GenomicRanges::GRangesList()
```

> For each set of promoters, check the enrichment of each TF motif in it

```r
library(plyranges)
ce11_proms <- SummarizedExperiment::rowRanges(readRDS('data/ATAC_worm/quantif.rds'))
enrichments <- BiocParallel::bplapply(names(motifs_hits), function(TF) {
    tibble::tibble(
        isprom = TRUE,
        overlap = ce11_proms %over% motifs_hits[[TF]], 
        tissue = ce11_proms$which.tissues
    ) %>% 
        group_by(tissue) %>% 
        summarize(
            TF = TF,
            nProms = sum(isprom), 
            nTF = sum(overlap), 
            nProms_tot = length(ce11_proms)
        )
}) %>% 
    bind_rows() %>% 
    left_join(tibble(TF = names(motifs_hits), nTF_tot = sapply(motifs_hits, function(x) sum(x %over% ce11_proms)))) %>%
    mutate(
        a = nTF,
        b = nTF_tot - nTF,
        c = nProms - nTF,
        d = nProms_tot - nTF_tot - nProms + nTF
    ) %>% 
    rowwise() %>% 
    mutate(
        pval = fisher.test(matrix(c(a, b, c, d), ncol = 2))$p.value,
        odd = fisher.test(matrix(c(a, b, c, d), ncol = 2))$estimate
    ) %>% select(-a, -b, -c, -d)
enrichments %>% filter(pval < 0.01, odd > 3) %>% arrange(tissue)
```

> Check promoter groups against a list of TF binding locations (by ChIP)

```r
beds <- list.files('data/ATAC_worm/ChIP', full.names = TRUE)
TF_peaks <- lapply(beds, rtracklayer::import)
names(TF_peaks) <- basename(beds) %>% str_replace_all('.bed|', '')
enrichments <- BiocParallel::bplapply(names(TF_peaks), function(TF) {
    tibble::tibble(
        isprom = TRUE,
        overlap = ce11_proms %over% TF_peaks[[TF]], 
        tissue = ce11_proms$which.tissues
    ) %>% 
        group_by(tissue) %>% 
        summarize(
            TF = TF,
            nProms = sum(isprom), 
            nTF = sum(overlap), 
            nProms_tot = length(ce11_proms)
        )
}) %>% 
    bind_rows() %>% 
    left_join(tibble(TF = names(TF_peaks), nTF_tot = sapply(TF_peaks, function(x) sum(x %over% ce11_proms)))) %>%
    mutate(
        a = nTF,
        b = nTF_tot - nTF,
        c = nProms - nTF,
        d = nProms_tot - nTF_tot - nProms + nTF
    ) %>% 
    rowwise() %>% 
    mutate(
        pval = fisher.test(matrix(c(a, b, c, d), ncol = 2))$p.value,
        odd = fisher.test(matrix(c(a, b, c, d), ncol = 2))$estimate
    ) %>% select(-a, -b, -c, -d)
enrichments %>% filter(pval < 1e-5, odd > 3) %>% arrange(tissue) %>% print(n = 'all')
```

### Hands-on session 6: chromVAR on human single-cell ATAC-seq

> Download raw data 

```shell
## -- Downloading tracks 
mkdir data/scATAC_human
cd data/scATAC_human
cat download.txt | parallel --bar -j 16 {}
mv SRR* fastq/
cd ../..
```

> Process raw data 

```shell
## -- Process data 
GENOME=~/genomes/hg38/hg38.fa
CPU=16

for SAMPLE in `ls data/scATAC_human/fastq/SRR* | sed 's,_Homo_.*,,' | sed 's,data/scATAC_human/fastq/,,' | uniq`
do
    R1=data/scATAC_human/fastq/"${SAMPLE}"_Homo_sapiens_OTHER_1.fastq.gz
    R2=data/scATAC_human/fastq/"${SAMPLE}"_Homo_sapiens_OTHER_2.fastq.gz
    bowtie2 --threads "${CPU}" -x "${GENOME}" --maxins 1000 -1 "${R1}" -2 "${R2}" | \
        samtools fixmate -@ "${CPU}" --output-fmt bam -m - - | \
        samtools sort -@ "${CPU}" --output-fmt bam -T data/scATAC_human/"${SAMPLE}".sam_sorting - | \
        samtools markdup -@ "${CPU}" --output-fmt bam -r -T data/scATAC_human/"${SAMPLE}".sam_markdup - - | \
        samtools view -@ "${CPU}" --output-fmt bam -f 2 -q 10 -1 -b - | \
        samtools sort -@ "${CPU}" --output-fmt bam -l 9 -T data/scATAC_human/"${SAMPLE}".sam_sorting2 -o data/scATAC_human/bam/"${SAMPLE}"_filtered.bam
    samtools index -@ "${CPU}" data/scATAC_human/bam/"${SAMPLE}"_filtered.bam
done

## -- Merge all bams
samtools merge -@ 12 -r -p `ls data/scATAC_human/bam/*bam` -o data/scATAC_human/384_cells.bam
samtools sort -@ 12 --output-fmt bam -l 9 -T data/scATAC_human/384_cells_sorting -o data/scATAC_human/384_cells_sorted.bam data/scATAC_human/384_cells.bam
samtools index data/scATAC_human/384_cells_sorted.bam

## -- Call peaks
macs2 callpeak -t data/scATAC_human/384_cells_sorted.bam --format BAMPE --gsize 2900000000 --outdir data/scATAC_human/peaks --name 384_cells

## -- Make track
bamCoverage \
    --bam data/scATAC_human/384_cells_sorted.bam \
    --outFileName data/scATAC_human/384_cells_sorted.bw \
    --binSize 10 \
    --numberOfProcessors 12 \
    --normalizeUsing CPM \
    --skipNonCoveredRegions \
    --extendReads
```

> Get a SummarizedExperiment of scATACseq counts over DHS sites

```r
library(tidyverse)
library(SummarizedExperiment)
library(plyranges)
BiocParallel::register(BiocParallel::MulticoreParam(16, progressbar = TRUE))

## -- Get peaks 
peaks <- rtracklayer::import('data/scATAC_human/peaks/384_cells_peaks.narrowPeak') %>% 
    mutate(start = start + peak) %>% 
    resize(width = 1, fix = 'start') %>% 
    resize(width = 200, fix = 'center')

## -- Import scATACseq fragments 
ga <- GenomicAlignments::readGAlignmentPairs(
    'data/scATAC_human/384_cells_sorted.bam', 
    use.names = TRUE, 
    param = Rsamtools::ScanBamParam(tag = "RG")
)
mcols(ga)$RG <- GRanges(first(ga))$RG
ga <- ga %>% 
    GRanges() %>%
    mutate(
        cellid = as_tibble(.) %>% separate(RG, into = c(NA, NA, 'cellID', NA), sep = '_') %>% pull(cellID)
    )
   
## -- Find overlaps between fragments and peaks
ovPEAK <- GenomicRanges::findOverlaps(peaks, ga)

## -- List cell barcodes
uniqueBarcodes <- unique(ga$cellid)
id <- factor(ga$cellid, levels = uniqueBarcodes)

## -- Assemble counts as a Sparse matrix
countdf <- data.frame(
    peaks = queryHits(ovPEAK),
    sample = id[subjectHits(ovPEAK)],
    read = names(ga)[subjectHits(ovPEAK)]
) %>%
    distinct() %>%
    select(-one_of("read")) %>% 
    group_by(peaks, sample) %>% 
    tally() %>% 
    data.matrix()
cnts <- Matrix::sparseMatrix(
    i = c(countdf[,1], length(peaks)),
    j = c(countdf[,2], length(uniqueBarcodes)),
    x = c(countdf[,3],0)
)
colnames(cnts) <- uniqueBarcodes

## -- Generate colData
depth <- data.frame(
    sample = as.numeric(id),
    read = names(ga)
) %>%
    distinct() %>% 
    group_by(sample) %>% 
    tally() %>% 
    data.matrix()
colData <- data.frame(
    sample = uniqueBarcodes,
    depth = depth[,2],
    FRIP = Matrix::colSums(cnts)/depth[,2], 
    celltype = str_replace_all(uniqueBarcodes, "singles-SU070-|singles-SU353-|singles-PB1022-|BM1077-", '') %>% str_replace_all('-.*', '')
)

## -- Make summarized Experiment
sumExp <- SummarizedExperiment::SummarizedExperiment(
    rowRanges = peaks, 
    assays = list(counts = cnts),
    colData = colData
)
saveRDS(sumExp, 'data/scATAC_human/sumExp.rds')
```

> Filter cells and promoters

```r
sumExp <- chromVAR::filterSamples(
    sumExp,
    min_depth = 1000, 
    min_in_peaks = 0.10, 
    shiny = FALSE
)
sumExp <- sumExp[rowSums(assay(sumExp)) > 10, ]
```

> Add GC bias to promoters 

```r
sumExp <- chromVAR::addGCBias(sumExp, genome = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38)
```

> Search for motifs with high deviation from background distribution 

```r
motifs <- TFBSTools::getMatrixSet(
    JASPAR2020::JASPAR2020,
    list(species = 9606, all_versions = FALSE)
)
motif_ix <- motifmatchr::matchMotifs(motifs, sumExp, genome = BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38)
bg <- chromVAR::getBackgroundPeaks(object = sumExp)
dev <- chromVAR::computeDeviations(object = sumExp, annotations = motif_ix, background_peaks = bg)
```

> Check deviations 

```r
variability <- chromVAR::computeVariability(dev)
p <- chromVAR::plotVariability(variability, use_plotly = FALSE) 
tsne_results <- chromVAR::deviationsTsne(dev, threshold = 1.5)
p <- cowplot::plot_grid(
    chromVAR::plotDeviationsTsne(dev, tsne_results, sample_column = "celltype", shiny = FALSE)[[1]], 
    chromVAR::plotDeviationsTsne(dev, tsne_results, annotation_name = "FOS", shiny = FALSE)[[1]], 
    chromVAR::plotDeviationsTsne(dev, tsne_results, annotation_name = "CEBPA", shiny = FALSE)[[1]], 
    chromVAR::plotDeviationsTsne(dev, tsne_results, annotation_name = "HIF1A", shiny = FALSE)[[1]]
)
```

